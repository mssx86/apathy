From 03a634ff2733f86fd9f70c06123bf789779d130f Mon Sep 17 00:00:00 2001
From: Thomas Deutschmann <whissi@gentoo.org>
Date: Fri, 21 May 2021 17:21:59 +0200
Subject: [PATCH 43/44] bmo#1661027: Update `cc` crate to v1.0.59

Signed-off-by: Thomas Deutschmann <whissi@gentoo.org>
---
 Cargo.lock                                  |   5 +-
 third_party/rust/cc/.cargo-checksum.json    |   2 +-
 third_party/rust/cc/Cargo.lock              | 133 +++--
 third_party/rust/cc/Cargo.toml              |  12 +-
 third_party/rust/cc/README.md               |   3 +-
 third_party/rust/cc/src/lib.rs              | 574 +++++++++++++++-----
 third_party/rust/cc/src/windows_registry.rs |  90 ++-
 third_party/rust/cc/tests/support/mod.rs    |  16 +-
 third_party/rust/cc/tests/test.rs           |  36 ++
 9 files changed, 621 insertions(+), 250 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 42a245ce80..aec9e964d2 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -514,12 +514,11 @@ checksum = "926013f2860c46252efceabb19f4a6b308197505082c609025aa6706c011d427"
 
 [[package]]
 name = "cc"
-version = "1.0.47"
+version = "1.0.59"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aa87058dce70a3ff5621797f1506cb837edd02ac4c0ae642b4542dce802908b8"
+checksum = "66120af515773fb005778dc07c261bd201ec8ce50bd6e7144c927753fe013381"
 dependencies = [
  "jobserver",
- "num_cpus",
 ]
 
 [[package]]
diff --git a/third_party/rust/cc/.cargo-checksum.json b/third_party/rust/cc/.cargo-checksum.json
index 417fde7953..a9252fa545 100644
--- a/third_party/rust/cc/.cargo-checksum.json
+++ b/third_party/rust/cc/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.lock":"3aff5f8b0a7f4d72852b11b0526f0002e6bf55f19f1ebd6470d7f97fbd540e60","Cargo.toml":"6ab10d9b6a9c6f0909074e6698c90c6b6a7223661ec2e83174d2593117cbe7f2","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397","README.md":"7184fbdf375a057e673257348f6d7584c0dd11b66318d98f3647f69eb610b097","src/bin/gcc-shim.rs":"b77907875029494b6288841c3aed2e4939ed40708c7f597fca5c9e2570490ca6","src/com.rs":"bcdaf1c28b71e6ef889c6b08d1ce9d7c0761344a677f523bc4c3cd297957f804","src/lib.rs":"4753929dbb7b676c19d7cfa06d0a47e37003554b80c536cbf2b892d591ef61c2","src/registry.rs":"3cc1b5a50879fa751572878ae1d0afbfc960c11665258492754b2c8bccb0ff5d","src/setup_config.rs":"7014103587d3382eac599cb76f016e2609b8140970861b2237982d1db24af265","src/winapi.rs":"ea8b7edbb9ff87957254f465c2334e714c5d6b3b19a8d757c48ea7ca0881c50c","src/windows_registry.rs":"388e79dcf3e84078ae0b086c6cdee9cf9eb7e3ffafdcbf3e2df26163661f5856","tests/cc_env.rs":"e02b3b0824ad039b47e4462c5ef6dbe6c824c28e7953af94a0f28f7b5158042e","tests/cflags.rs":"57f06eb5ce1557e5b4a032d0c4673e18fbe6f8d26c1deb153126e368b96b41b3","tests/cxxflags.rs":"c2c6c6d8a0d7146616fa1caed26876ee7bc9fcfffd525eb4743593cade5f3371","tests/support/mod.rs":"71620b178583b6e6e5e0d4cac14e2cef6afc62fb6841e0c72ed1784543abf8ac","tests/test.rs":"1605640c9b94a77f48fc92e1dc0485bdf1960da5626e2e00279e4703691656bc"},"package":"aa87058dce70a3ff5621797f1506cb837edd02ac4c0ae642b4542dce802908b8"}
\ No newline at end of file
+{"files":{"Cargo.lock":"bd34a585a35969291c78b96b1f239fa09f1f9dbeee48474989695def1ed64052","Cargo.toml":"cb73923110f764c2a6da0fde98db8f5f7c7194bd56e96e2f302da9ba29cba0a8","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397","README.md":"68fe1bc9f8aab4d8d195e8bc39fe76562742dc392f5c490e5404e01463100277","src/bin/gcc-shim.rs":"b77907875029494b6288841c3aed2e4939ed40708c7f597fca5c9e2570490ca6","src/com.rs":"bcdaf1c28b71e6ef889c6b08d1ce9d7c0761344a677f523bc4c3cd297957f804","src/lib.rs":"96f4782c70e0bd8d9ab7ce3efcc2091d2591c3276c0ed672e2379748bb3930aa","src/registry.rs":"3cc1b5a50879fa751572878ae1d0afbfc960c11665258492754b2c8bccb0ff5d","src/setup_config.rs":"7014103587d3382eac599cb76f016e2609b8140970861b2237982d1db24af265","src/winapi.rs":"ea8b7edbb9ff87957254f465c2334e714c5d6b3b19a8d757c48ea7ca0881c50c","src/windows_registry.rs":"52afe8554f577c87841c48ddee3ba7ffe70a00129e1d6eeb2ec0efb3d2b9aa11","tests/cc_env.rs":"e02b3b0824ad039b47e4462c5ef6dbe6c824c28e7953af94a0f28f7b5158042e","tests/cflags.rs":"57f06eb5ce1557e5b4a032d0c4673e18fbe6f8d26c1deb153126e368b96b41b3","tests/cxxflags.rs":"c2c6c6d8a0d7146616fa1caed26876ee7bc9fcfffd525eb4743593cade5f3371","tests/support/mod.rs":"16274867f23871e9b07614eda4c7344da13d1751fed63d4f633857e40be86394","tests/test.rs":"65c073e0e2cf4aa0433066102788e9f57442719e6f32f5ad5248aa7132bb4597"},"package":"66120af515773fb005778dc07c261bd201ec8ce50bd6e7144c927753fe013381"}
\ No newline at end of file
diff --git a/third_party/rust/cc/Cargo.lock b/third_party/rust/cc/Cargo.lock
index ee899568d1..a624f35455 100644
--- a/third_party/rust/cc/Cargo.lock
+++ b/third_party/rust/cc/Cargo.lock
@@ -2,153 +2,144 @@
 # It is not intended for manual editing.
 [[package]]
 name = "cc"
-version = "1.0.47"
+version = "1.0.59"
 dependencies = [
- "jobserver 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)",
- "num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "jobserver",
+ "tempfile",
 ]
 
 [[package]]
 name = "cfg-if"
 version = "0.1.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "fuchsia-cprng"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"
 
 [[package]]
 name = "getrandom"
-version = "0.1.12"
+version = "0.1.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7abc8dd8451921606d809ba32e95b6111925cd2906060d2dcc29c070220503eb"
 dependencies = [
- "cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.64 (registry+https://github.com/rust-lang/crates.io-index)",
- "wasi 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cfg-if",
+ "libc",
+ "wasi",
 ]
 
 [[package]]
 name = "jobserver"
-version = "0.1.17"
+version = "0.1.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c71313ebb9439f74b00d9d2dcec36440beaf57a6aa0623068441dd7cd81a7f2"
 dependencies = [
- "getrandom 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.64 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc",
 ]
 
 [[package]]
 name = "libc"
-version = "0.2.64"
+version = "0.2.74"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a2f02823cf78b754822df5f7f268fb59822e7296276d3e069d8e8cb26a14bd10"
 
 [[package]]
-name = "log"
-version = "0.4.8"
+name = "ppv-lite86"
+version = "0.2.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)",
-]
+checksum = "237a5ed80e274dbc66f86bd59c1e25edc039660be53194b5fe0a482e0f2612ea"
 
 [[package]]
-name = "num_cpus"
-version = "1.10.1"
+name = "rand"
+version = "0.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
 dependencies = [
- "libc 0.2.64 (registry+https://github.com/rust-lang/crates.io-index)",
+ "getrandom",
+ "libc",
+ "rand_chacha",
+ "rand_core",
+ "rand_hc",
 ]
 
 [[package]]
-name = "rand"
-version = "0.4.6"
+name = "rand_chacha"
+version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402"
 dependencies = [
- "fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.64 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "ppv-lite86",
+ "rand_core",
 ]
 
 [[package]]
 name = "rand_core"
-version = "0.3.1"
+version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19"
 dependencies = [
- "rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "getrandom",
 ]
 
 [[package]]
-name = "rand_core"
-version = "0.4.2"
+name = "rand_hc"
+version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c"
+dependencies = [
+ "rand_core",
+]
 
 [[package]]
-name = "rdrand"
-version = "0.4.0"
+name = "redox_syscall"
+version = "0.1.57"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
+checksum = "41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce"
 
 [[package]]
 name = "remove_dir_all"
-version = "0.5.2"
+version = "0.5.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7"
 dependencies = [
- "winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi",
 ]
 
 [[package]]
-name = "tempdir"
-version = "0.3.7"
+name = "tempfile"
+version = "3.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9"
 dependencies = [
- "rand 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cfg-if",
+ "libc",
+ "rand",
+ "redox_syscall",
+ "remove_dir_all",
+ "winapi",
 ]
 
 [[package]]
 name = "wasi"
-version = "0.7.0"
+version = "0.9.0+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"
 
 [[package]]
 name = "winapi"
-version = "0.3.8"
+version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
 dependencies = [
- "winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-i686-pc-windows-gnu",
+ "winapi-x86_64-pc-windows-gnu",
 ]
 
 [[package]]
 name = "winapi-i686-pc-windows-gnu"
 version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
 
 [[package]]
 name = "winapi-x86_64-pc-windows-gnu"
 version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[metadata]
-"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)" = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"
-"checksum fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba"
-"checksum getrandom 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)" = "473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571"
-"checksum jobserver 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)" = "f2b1d42ef453b30b7387e113da1c83ab1605d90c5b4e0eb8e96d016ed3b8c160"
-"checksum libc 0.2.64 (registry+https://github.com/rust-lang/crates.io-index)" = "74dfca3d9957906e8d1e6a0b641dc9a59848e793f1da2165889fd4f62d10d79c"
-"checksum log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)" = "14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7"
-"checksum num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)" = "bcef43580c035376c0705c42792c294b66974abbfd2789b511784023f71f3273"
-"checksum rand 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)" = "552840b97013b1a26992c11eac34bdd778e464601a4c2054b5f0bff7c6761293"
-"checksum rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b"
-"checksum rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc"
-"checksum rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2"
-"checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)" = "4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e"
-"checksum tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)" = "15f2b5fb00ccdf689e0149d1b1b3c03fead81c2b37735d812fa8bddbbf41b6d8"
-"checksum wasi 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d"
-"checksum winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)" = "8093091eeb260906a183e6ae1abdba2ef5ef2257a21801128899c3fc699229c6"
-"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
-"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
+checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
diff --git a/third_party/rust/cc/Cargo.toml b/third_party/rust/cc/Cargo.toml
index 8efe26374c..2b3aac577f 100644
--- a/third_party/rust/cc/Cargo.toml
+++ b/third_party/rust/cc/Cargo.toml
@@ -13,7 +13,7 @@
 [package]
 edition = "2018"
 name = "cc"
-version = "1.0.47"
+version = "1.0.59"
 authors = ["Alex Crichton <alex@alexcrichton.com>"]
 exclude = ["/.travis.yml", "/appveyor.yml"]
 description = "A build-time dependency for Cargo build scripts to assist in invoking the native\nC compiler to compile native C code into a static archive to be linked into Rust\ncode.\n"
@@ -27,12 +27,8 @@ repository = "https://github.com/alexcrichton/cc-rs"
 [dependencies.jobserver]
 version = "0.1.16"
 optional = true
-
-[dependencies.num_cpus]
-version = "1.10"
-optional = true
-[dev-dependencies.tempdir]
-version = "0.3"
+[dev-dependencies.tempfile]
+version = "3"
 
 [features]
-parallel = ["num_cpus", "jobserver"]
+parallel = ["jobserver"]
diff --git a/third_party/rust/cc/README.md b/third_party/rust/cc/README.md
index 68448aceca..e147d7e177 100644
--- a/third_party/rust/cc/README.md
+++ b/third_party/rust/cc/README.md
@@ -39,7 +39,7 @@ application will now have the C files `foo.c` and `bar.c` compiled into a file
 named libfoo.a. You can call the functions in Rust by declaring functions in
 your Rust code like so:
 
-```
+```rust,no_run
 extern {
     fn foo_function();
     fn bar_function();
@@ -150,6 +150,7 @@ fn main() {
 When using C++ library compilation switch, the `CXX` and `CXXFLAGS` env
 variables are used instead of `CC` and `CFLAGS` and the C++ standard library is
 linked to the crate target.
+Remember that C++ does name mangling so `extern "C"` might be required to enable rust linker to find your functions.
 
 ## CUDA C++ support
 
diff --git a/third_party/rust/cc/src/lib.rs b/third_party/rust/cc/src/lib.rs
index 621d31d6b8..fecc073056 100644
--- a/third_party/rust/cc/src/lib.rs
+++ b/third_party/rust/cc/src/lib.rs
@@ -120,6 +120,7 @@ pub struct Build {
     warnings: Option<bool>,
     extra_warnings: Option<bool>,
     env_cache: Arc<Mutex<HashMap<String, Option<String>>>>,
+    apple_sdk_root_cache: Arc<Mutex<HashMap<String, OsString>>>,
 }
 
 /// Represents the types of errors that may occur while using cc-rs.
@@ -167,6 +168,8 @@ impl Display for Error {
     }
 }
 
+impl std::error::Error for Error {}
+
 /// Configuration used to represent an invocation of a C compiler.
 ///
 /// This can be used to figure out what compiler is in use, what the arguments
@@ -310,6 +313,7 @@ impl Build {
             extra_warnings: None,
             warnings_into_errors: false,
             env_cache: Arc::new(Mutex::new(HashMap::new())),
+            apple_sdk_root_cache: Arc::new(Mutex::new(HashMap::new())),
         }
     }
 
@@ -412,7 +416,7 @@ impl Build {
     /// For a convenience method for setting flags conditionally,
     /// see `flag_if_supported()`.
     ///
-    /// It may return error if it's unable to run the compilier with a test file
+    /// It may return error if it's unable to run the compiler with a test file
     /// (e.g. the compiler is missing or a write to the `out_dir` failed).
     ///
     /// Note: Once computed, the result of this call is stored in the
@@ -447,11 +451,13 @@ impl Build {
 
         let mut cmd = compiler.to_command();
         let is_arm = target.contains("aarch64") || target.contains("arm");
+        let clang = compiler.family == ToolFamily::Clang;
         command_add_output_file(
             &mut cmd,
             &obj,
             self.cuda,
             target.contains("msvc"),
+            clang,
             false,
             is_arm,
         );
@@ -845,7 +851,7 @@ impl Build {
 
     /// Configures whether the compiler will emit position independent code.
     ///
-    /// This option defaults to `false` for `windows-gnu` and `riscv` targets and
+    /// This option defaults to `false` for `windows-gnu` and bare metal targets and
     /// to `true` for all other targets.
     pub fn pic(&mut self, pic: bool) -> &mut Build {
         self.pic = Some(pic);
@@ -964,7 +970,7 @@ impl Build {
     /// Run the compiler, generating the file `output`
     ///
     /// The name `output` should be the name of the library.  For backwards compatibility,
-    /// the `output` may start with `lib` and end with `.a`.  The Rust compilier will create
+    /// the `output` may start with `lib` and end with `.a`.  The Rust compiler will create
     /// the assembly with the lib prefix and .a extension.  MSVC will create a file without prefix,
     /// ending with `.lib`.
     ///
@@ -1099,9 +1105,13 @@ impl Build {
                 return client;
             }
 
-            // ... but if that fails for whatever reason fall back to the number
-            // of cpus on the system or the `NUM_JOBS` env var.
-            let mut parallelism = num_cpus::get();
+            // ... but if that fails for whatever reason select something
+            // reasonable and crate a new jobserver. Use `NUM_JOBS` if set (it's
+            // configured by Cargo) and otherwise just fall back to a
+            // semi-reasonable number. Note that we could use `num_cpus` here
+            // but it's an extra dependency that will almost never be used, so
+            // it's generally not too worth it.
+            let mut parallelism = 4;
             if let Ok(amt) = env::var("NUM_JOBS") {
                 if let Ok(amt) = amt.parse() {
                     parallelism = amt;
@@ -1138,10 +1148,11 @@ impl Build {
         let is_asm = obj.src.extension().and_then(|s| s.to_str()) == Some("asm");
         let target = self.get_target()?;
         let msvc = target.contains("msvc");
+        let compiler = self.try_get_compiler()?;
+        let clang = compiler.family == ToolFamily::Clang;
         let (mut cmd, name) = if msvc && is_asm {
             self.msvc_macro_assembler()?
         } else {
-            let compiler = self.try_get_compiler()?;
             let mut cmd = compiler.to_command();
             for &(ref a, ref b) in self.env.iter() {
                 cmd.env(a, b);
@@ -1157,12 +1168,15 @@ impl Build {
             )
         };
         let is_arm = target.contains("aarch64") || target.contains("arm");
-        command_add_output_file(&mut cmd, &obj.dst, self.cuda, msvc, is_asm, is_arm);
+        command_add_output_file(&mut cmd, &obj.dst, self.cuda, msvc, clang, is_asm, is_arm);
         // armasm and armasm64 don't requrie -c option
         if !msvc || !is_asm || !is_arm {
             cmd.arg("-c");
         }
         cmd.arg(&obj.src);
+        if cfg!(target_os = "macos") {
+            self.fix_env_for_apple_os(&mut cmd)?;
+        }
 
         run(&mut cmd, &name)?;
         Ok(())
@@ -1361,14 +1375,23 @@ impl Build {
                     cmd.push_opt_unless_duplicate(format!("-O{}", opt_level).into());
                 }
 
+                if cmd.family == ToolFamily::Clang && target.contains("android") {
+                    // For compatibility with code that doesn't use pre-defined `__ANDROID__` macro.
+                    // If compiler used via ndk-build or cmake (officially supported build methods)
+                    // this macros is defined.
+                    // See https://android.googlesource.com/platform/ndk/+/refs/heads/ndk-release-r21/build/cmake/android.toolchain.cmake#456
+                    // https://android.googlesource.com/platform/ndk/+/refs/heads/ndk-release-r21/build/core/build-binary.mk#141
+                    cmd.push_opt_unless_duplicate("-DANDROID".into());
+                }
+
                 if !target.contains("-ios") {
                     cmd.push_cc_arg("-ffunction-sections".into());
                     cmd.push_cc_arg("-fdata-sections".into());
                 }
-                // Disable generation of PIC on RISC-V for now: rust-lld doesn't support this yet
+                // Disable generation of PIC on bare-metal for now: rust-lld doesn't support this yet
                 if self
                     .pic
-                    .unwrap_or(!target.contains("windows-gnu") && !target.contains("riscv"))
+                    .unwrap_or(!target.contains("windows") && !target.contains("-none-"))
                 {
                     cmd.push_cc_arg("-fPIC".into());
                     // PLT only applies if code is compiled with PIC support,
@@ -1397,19 +1420,23 @@ impl Build {
         // Target flags
         match cmd.family {
             ToolFamily::Clang => {
-                cmd.args.push(format!("--target={}", target).into());
+                if !(target.contains("android")
+                    && android_clang_compiler_uses_target_arg_internally(&cmd.path))
+                {
+                    cmd.args.push(format!("--target={}", target).into());
+                }
             }
             ToolFamily::Msvc { clang_cl } => {
                 // This is an undocumented flag from MSVC but helps with making
                 // builds more reproducible by avoiding putting timestamps into
                 // files.
-                cmd.args.push("-Brepro".into());
+                cmd.push_cc_arg("-Brepro".into());
 
                 if clang_cl {
                     if target.contains("x86_64") {
-                        cmd.args.push("-m64".into());
+                        cmd.push_cc_arg("-m64".into());
                     } else if target.contains("86") {
-                        cmd.args.push("-m32".into());
+                        cmd.push_cc_arg("-m32".into());
                         cmd.push_cc_arg("-arch:IA32".into());
                     } else {
                         cmd.push_cc_arg(format!("--target={}", target).into());
@@ -1443,6 +1470,19 @@ impl Build {
                     cmd.args.push("-m64".into());
                 }
 
+                if target.contains("darwin") {
+                    if target.contains("x86_64") {
+                        cmd.args.push("-arch".into());
+                        cmd.args.push("x86_64".into());
+                    } else if target.contains("arm64e") {
+                        cmd.args.push("-arch".into());
+                        cmd.args.push("arm64e".into());
+                    } else if target.contains("aarch64") {
+                        cmd.args.push("-arch".into());
+                        cmd.args.push("arm64".into());
+                    }
+                }
+
                 if self.static_flag.is_none() {
                     let features = self
                         .getenv("CARGO_CFG_TARGET_FEATURE")
@@ -1582,19 +1622,30 @@ impl Build {
                         cmd.args.push("-mfloat-abi=soft".into());
                     }
                 }
+                if target.starts_with("armv7a") {
+                    cmd.args.push("-march=armv7-a".into());
+
+                    if target.ends_with("eabihf") {
+                        // lowest common denominator FPU
+                        cmd.args.push("-mfpu=vfpv3-d16".into());
+                    }
+                }
                 if target.starts_with("riscv32") || target.starts_with("riscv64") {
                     // get the 32i/32imac/32imc/64gc/64imac/... part
                     let mut parts = target.split('-');
                     if let Some(arch) = parts.next() {
                         let arch = &arch[5..];
                         cmd.args.push(("-march=rv".to_owned() + arch).into());
-                        // ABI is always soft-float right now, update this when this is no longer the
-                        // case:
-                        if arch.starts_with("64") {
+                        if target.contains("linux") && arch.starts_with("64") {
+                            cmd.args.push("-mabi=lp64d".into());
+                        } else if target.contains("linux") && arch.starts_with("32") {
+                            cmd.args.push("-mabi=ilp32d".into());
+                        } else if arch.starts_with("64") {
                             cmd.args.push("-mabi=lp64".into());
                         } else {
                             cmd.args.push("-mabi=ilp32".into());
                         }
+                        cmd.args.push("-mcmodel=medany".into());
                     }
                 }
             }
@@ -1654,14 +1705,19 @@ impl Build {
             "ml.exe"
         };
         let mut cmd = windows_registry::find(&target, tool).unwrap_or_else(|| self.cmd(tool));
+        cmd.arg("-nologo"); // undocumented, yet working with armasm[64]
         for directory in self.include_directories.iter() {
             cmd.arg("-I").arg(directory);
         }
-        for &(ref key, ref value) in self.definitions.iter() {
-            if let Some(ref value) = *value {
-                cmd.arg(&format!("-D{}={}", key, value));
-            } else {
-                cmd.arg(&format!("-D{}", key));
+        if target.contains("aarch64") || target.contains("arm") {
+            println!("cargo:warning=The MSVC ARM assemblers do not support -D flags");
+        } else {
+            for &(ref key, ref value) in self.definitions.iter() {
+                if let Some(ref value) = *value {
+                    cmd.arg(&format!("-D{}={}", key, value));
+                } else {
+                    cmd.arg(&format!("-D{}", key));
+                }
             }
         }
 
@@ -1804,6 +1860,7 @@ impl Build {
         let arch = match arch {
             "arm" | "armv7" | "thumbv7" => ArchSpec::Device("armv7"),
             "armv7s" | "thumbv7s" => ArchSpec::Device("armv7s"),
+            "arm64e" => ArchSpec::Device("arm64e"),
             "arm64" | "aarch64" => ArchSpec::Device("arm64"),
             "i386" | "i686" => ArchSpec::Simulator("-m32"),
             "x86_64" => ArchSpec::Simulator("-m64"),
@@ -1835,30 +1892,12 @@ impl Build {
         };
 
         self.print(&format!("Detecting iOS SDK path for {}", sdk));
-        let sdk_path = self
-            .cmd("xcrun")
-            .arg("--show-sdk-path")
-            .arg("--sdk")
-            .arg(sdk)
-            .stderr(Stdio::inherit())
-            .output()?
-            .stdout;
-
-        let sdk_path = match String::from_utf8(sdk_path) {
-            Ok(p) => p,
-            Err(_) => {
-                return Err(Error::new(
-                    ErrorKind::IOError,
-                    "Unable to determine iOS SDK path.",
-                ));
-            }
-        };
-
+        let sdk_path = self.apple_sdk_root(sdk)?;
         cmd.args.push("-isysroot".into());
-        cmd.args.push(sdk_path.trim().into());
+        cmd.args.push(sdk_path);
         cmd.args.push("-fembed-bitcode".into());
         /*
-         * TODO we probably ultimatedly want the -fembed-bitcode-marker flag
+         * TODO we probably ultimately want the -fembed-bitcode-marker flag
          * but can't have it now because of an issue in LLVM:
          * https://github.com/alexcrichton/cc-rs/issues/301
          * https://github.com/rust-lang/rust/pull/48896#comment-372192660
@@ -1892,8 +1931,11 @@ impl Build {
             ("CC", "cl.exe", "gcc", "cc", "clang")
         };
 
-        // On Solaris, c++/cc unlikely to exist or be correct.
-        let default = if host.contains("solaris") {
+        // On historical Solaris systems, "cc" may have been Sun Studio, which
+        // is not flag-compatible with "gcc".  This history casts a long shadow,
+        // and many modern illumos distributions today ship GCC as "gcc" without
+        // also making it available as "cc".
+        let default = if host.contains("solaris") || host.contains("illumos") {
             gnu
         } else {
             traditional
@@ -1910,13 +1952,13 @@ impl Build {
                     .iter()
                     .find(|a| a.starts_with(DRIVER_MODE))
                     .map(|a| &a[DRIVER_MODE.len()..]);
-                // chop off leading/trailing whitespace to work around
+                // Chop off leading/trailing whitespace to work around
                 // semi-buggy build scripts which are shared in
                 // makefiles/configure scripts (where spaces are far more
                 // lenient)
                 let mut t = Tool::with_clang_driver(PathBuf::from(tool.trim()), driver_mode);
-                if let Some(cc) = wrapper {
-                    t.cc_wrapper_path = Some(PathBuf::from(cc));
+                if let Some(cc_wrapper) = wrapper {
+                    t.cc_wrapper_path = Some(PathBuf::from(cc_wrapper));
                 }
                 for arg in args {
                     t.cc_wrapper_args.push(arg.into());
@@ -1951,20 +1993,7 @@ impl Build {
                         format!("{}.exe", gnu)
                     }
                 } else if target.contains("android") {
-                    let target = target
-                        .replace("armv7neon", "arm")
-                        .replace("armv7", "arm")
-                        .replace("thumbv7neon", "arm")
-                        .replace("thumbv7", "arm");
-                    let gnu_compiler = format!("{}-{}", target, gnu);
-                    let clang_compiler = format!("{}-{}", target, clang);
-                    // Check if gnu compiler is present
-                    // if not, use clang
-                    if Command::new(&gnu_compiler).spawn().is_ok() {
-                        gnu_compiler
-                    } else {
-                        clang_compiler
-                    }
+                    autodetect_android_compiler(&target, &host, gnu, clang)
                 } else if target.contains("cloudabi") {
                     format!("{}-{}", target, traditional)
                 } else if target == "wasm32-wasi"
@@ -1975,79 +2004,7 @@ impl Build {
                 } else if target.contains("vxworks") {
                     "wr-c++".to_string()
                 } else if self.get_host()? != target {
-                    // CROSS_COMPILE is of the form: "arm-linux-gnueabi-"
-                    let cc_env = self.getenv("CROSS_COMPILE");
-                    let cross_compile = cc_env.as_ref().map(|s| s.trim_right_matches('-'));
-                    let prefix = cross_compile.or(match &target[..] {
-                        "aarch64-unknown-linux-gnu" => Some("aarch64-linux-gnu"),
-                        "aarch64-unknown-linux-musl" => Some("aarch64-linux-musl"),
-                        "aarch64-unknown-netbsd" => Some("aarch64--netbsd"),
-                        "arm-unknown-linux-gnueabi" => Some("arm-linux-gnueabi"),
-                        "armv4t-unknown-linux-gnueabi" => Some("arm-linux-gnueabi"),
-                        "armv5te-unknown-linux-gnueabi" => Some("arm-linux-gnueabi"),
-                        "arm-frc-linux-gnueabi" => Some("arm-frc-linux-gnueabi"),
-                        "arm-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
-                        "arm-unknown-linux-musleabi" => Some("arm-linux-musleabi"),
-                        "arm-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
-                        "arm-unknown-netbsd-eabi" => Some("arm--netbsdelf-eabi"),
-                        "armv6-unknown-netbsd-eabihf" => Some("armv6--netbsdelf-eabihf"),
-                        "armv7-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
-                        "armv7-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
-                        "armv7neon-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
-                        "armv7neon-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
-                        "thumbv7-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
-                        "thumbv7-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
-                        "thumbv7neon-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
-                        "thumbv7neon-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
-                        "armv7-unknown-netbsd-eabihf" => Some("armv7--netbsdelf-eabihf"),
-                        "i586-unknown-linux-musl" => Some("musl"),
-                        "i686-pc-windows-gnu" => Some("i686-w64-mingw32"),
-                        "i686-uwp-windows-gnu" => Some("i686-w64-mingw32"),
-                        "i686-unknown-linux-musl" => Some("musl"),
-                        "i686-unknown-netbsd" => Some("i486--netbsdelf"),
-                        "mips-unknown-linux-gnu" => Some("mips-linux-gnu"),
-                        "mipsel-unknown-linux-gnu" => Some("mipsel-linux-gnu"),
-                        "mips64-unknown-linux-gnuabi64" => Some("mips64-linux-gnuabi64"),
-                        "mips64el-unknown-linux-gnuabi64" => Some("mips64el-linux-gnuabi64"),
-                        "mipsisa32r6-unknown-linux-gnu" => Some("mipsisa32r6-linux-gnu"),
-                        "mipsisa32r6el-unknown-linux-gnu" => Some("mipsisa32r6el-linux-gnu"),
-                        "mipsisa64r6-unknown-linux-gnuabi64" => Some("mipsisa64r6-linux-gnuabi64"),
-                        "mipsisa64r6el-unknown-linux-gnuabi64" => {
-                            Some("mipsisa64r6el-linux-gnuabi64")
-                        }
-                        "powerpc-unknown-linux-gnu" => Some("powerpc-linux-gnu"),
-                        "powerpc-unknown-linux-gnuspe" => Some("powerpc-linux-gnuspe"),
-                        "powerpc-unknown-netbsd" => Some("powerpc--netbsd"),
-                        "powerpc64-unknown-linux-gnu" => Some("powerpc-linux-gnu"),
-                        "powerpc64le-unknown-linux-gnu" => Some("powerpc64le-linux-gnu"),
-                        "riscv32i-unknown-none-elf" => Some("riscv32-unknown-elf"),
-                        "riscv32imac-unknown-none-elf" => Some("riscv32-unknown-elf"),
-                        "riscv32imc-unknown-none-elf" => Some("riscv32-unknown-elf"),
-                        "riscv64gc-unknown-none-elf" => Some("riscv64-unknown-elf"),
-                        "riscv64imac-unknown-none-elf" => Some("riscv64-unknown-elf"),
-                        "s390x-unknown-linux-gnu" => Some("s390x-linux-gnu"),
-                        "sparc-unknown-linux-gnu" => Some("sparc-linux-gnu"),
-                        "sparc64-unknown-linux-gnu" => Some("sparc64-linux-gnu"),
-                        "sparc64-unknown-netbsd" => Some("sparc64--netbsd"),
-                        "sparcv9-sun-solaris" => Some("sparcv9-sun-solaris"),
-                        "armebv7r-none-eabi" => Some("arm-none-eabi"),
-                        "armebv7r-none-eabihf" => Some("arm-none-eabi"),
-                        "armv7r-none-eabi" => Some("arm-none-eabi"),
-                        "armv7r-none-eabihf" => Some("arm-none-eabi"),
-                        "thumbv6m-none-eabi" => Some("arm-none-eabi"),
-                        "thumbv7em-none-eabi" => Some("arm-none-eabi"),
-                        "thumbv7em-none-eabihf" => Some("arm-none-eabi"),
-                        "thumbv7m-none-eabi" => Some("arm-none-eabi"),
-                        "thumbv8m.base-none-eabi" => Some("arm-none-eabi"),
-                        "thumbv8m.main-none-eabi" => Some("arm-none-eabi"),
-                        "thumbv8m.main-none-eabihf" => Some("arm-none-eabi"),
-                        "x86_64-pc-windows-gnu" => Some("x86_64-w64-mingw32"),
-                        "x86_64-uwp-windows-gnu" => Some("x86_64-w64-mingw32"),
-                        "x86_64-rumprun-netbsd" => Some("x86_64-rumprun-netbsd"),
-                        "x86_64-unknown-linux-musl" => Some("musl"),
-                        "x86_64-unknown-netbsd" => Some("x86_64--netbsd"),
-                        _ => None,
-                    });
+                    let prefix = self.prefix_for_target(&target);
                     match prefix {
                         Some(prefix) => format!("{}-{}", prefix, gnu),
                         None => default.to_string(),
@@ -2055,7 +2012,12 @@ impl Build {
                 } else {
                     default.to_string()
                 };
-                Tool::new(PathBuf::from(compiler))
+
+                let mut t = Tool::new(PathBuf::from(compiler));
+                if let Some(cc_wrapper) = Self::rustc_wrapper_fallback() {
+                    t.cc_wrapper_path = Some(PathBuf::from(cc_wrapper));
+                }
+                t
             }
         };
 
@@ -2131,6 +2093,24 @@ impl Build {
             .collect()
     }
 
+    /// Returns a fallback `cc_compiler_wrapper` by introspecting `RUSTC_WRAPPER`
+    fn rustc_wrapper_fallback() -> Option<String> {
+        // No explicit CC wrapper was detected, but check if RUSTC_WRAPPER
+        // is defined and is a build accelerator that is compatible with
+        // C/C++ compilers (e.g. sccache)
+        let valid_wrappers = ["sccache"];
+
+        let rustc_wrapper = std::env::var_os("RUSTC_WRAPPER")?;
+        let wrapper_path = Path::new(&rustc_wrapper);
+        let wrapper_stem = wrapper_path.file_stem()?;
+
+        if valid_wrappers.contains(&wrapper_stem.to_str()?) {
+            Some(rustc_wrapper.to_str()?.to_owned())
+        } else {
+            None
+        }
+    }
+
     /// Returns compiler path, optional modifier name from whitelist, and arguments vec
     fn env_tool(&self, name: &str) -> Option<(String, Option<String>, Vec<String>)> {
         let tool = match self.get_var(name) {
@@ -2190,7 +2170,7 @@ impl Build {
 
         Some((
             maybe_wrapper.to_string(),
-            None,
+            Self::rustc_wrapper_fallback(),
             parts.map(|s| s.to_string()).collect(),
         ))
     }
@@ -2234,6 +2214,7 @@ impl Build {
             return Ok((self.cmd(&p), p));
         }
         let target = self.get_target()?;
+        let default_ar = "ar".to_string();
         let program = if target.contains("android") {
             format!("{}-ar", target.replace("armv7", "arm"))
         } else if target.contains("emscripten") {
@@ -2250,12 +2231,159 @@ impl Build {
                 Some(t) => return Ok((t, "lib.exe".to_string())),
                 None => "lib.exe".to_string(),
             }
+        } else if self.get_host()? != target {
+            match self.prefix_for_target(&target) {
+                Some(p) => {
+                    let target_ar = format!("{}-ar", p);
+                    if Command::new(&target_ar).output().is_ok() {
+                        target_ar
+                    } else {
+                        default_ar
+                    }
+                }
+                None => default_ar,
+            }
         } else {
-            "ar".to_string()
+            default_ar
         };
         Ok((self.cmd(&program), program))
     }
 
+    fn prefix_for_target(&self, target: &str) -> Option<String> {
+        // CROSS_COMPILE is of the form: "arm-linux-gnueabi-"
+        let cc_env = self.getenv("CROSS_COMPILE");
+        let cross_compile = cc_env
+            .as_ref()
+            .map(|s| s.trim_right_matches('-').to_owned());
+        cross_compile.or(match &target[..] {
+            "aarch64-unknown-linux-gnu" => Some("aarch64-linux-gnu"),
+            "aarch64-unknown-linux-musl" => Some("aarch64-linux-musl"),
+            "aarch64-unknown-netbsd" => Some("aarch64--netbsd"),
+            "arm-unknown-linux-gnueabi" => Some("arm-linux-gnueabi"),
+            "armv4t-unknown-linux-gnueabi" => Some("arm-linux-gnueabi"),
+            "armv5te-unknown-linux-gnueabi" => Some("arm-linux-gnueabi"),
+            "armv5te-unknown-linux-musleabi" => Some("arm-linux-gnueabi"),
+            "arm-frc-linux-gnueabi" => Some("arm-frc-linux-gnueabi"),
+            "arm-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
+            "arm-unknown-linux-musleabi" => Some("arm-linux-musleabi"),
+            "arm-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
+            "arm-unknown-netbsd-eabi" => Some("arm--netbsdelf-eabi"),
+            "armv6-unknown-netbsd-eabihf" => Some("armv6--netbsdelf-eabihf"),
+            "armv7-unknown-linux-gnueabi" => Some("arm-linux-gnueabi"),
+            "armv7-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
+            "armv7-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
+            "armv7neon-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
+            "armv7neon-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
+            "thumbv7-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
+            "thumbv7-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
+            "thumbv7neon-unknown-linux-gnueabihf" => Some("arm-linux-gnueabihf"),
+            "thumbv7neon-unknown-linux-musleabihf" => Some("arm-linux-musleabihf"),
+            "armv7-unknown-netbsd-eabihf" => Some("armv7--netbsdelf-eabihf"),
+            "hexagon-unknown-linux-musl" => Some("hexagon-linux-musl"),
+            "i586-unknown-linux-musl" => Some("musl"),
+            "i686-pc-windows-gnu" => Some("i686-w64-mingw32"),
+            "i686-uwp-windows-gnu" => Some("i686-w64-mingw32"),
+            "i686-unknown-linux-musl" => Some("musl"),
+            "i686-unknown-netbsd" => Some("i486--netbsdelf"),
+            "mips-unknown-linux-gnu" => Some("mips-linux-gnu"),
+            "mipsel-unknown-linux-gnu" => Some("mipsel-linux-gnu"),
+            "mips64-unknown-linux-gnuabi64" => Some("mips64-linux-gnuabi64"),
+            "mips64el-unknown-linux-gnuabi64" => Some("mips64el-linux-gnuabi64"),
+            "mipsisa32r6-unknown-linux-gnu" => Some("mipsisa32r6-linux-gnu"),
+            "mipsisa32r6el-unknown-linux-gnu" => Some("mipsisa32r6el-linux-gnu"),
+            "mipsisa64r6-unknown-linux-gnuabi64" => Some("mipsisa64r6-linux-gnuabi64"),
+            "mipsisa64r6el-unknown-linux-gnuabi64" => Some("mipsisa64r6el-linux-gnuabi64"),
+            "powerpc-unknown-linux-gnu" => Some("powerpc-linux-gnu"),
+            "powerpc-unknown-linux-gnuspe" => Some("powerpc-linux-gnuspe"),
+            "powerpc-unknown-netbsd" => Some("powerpc--netbsd"),
+            "powerpc64-unknown-linux-gnu" => Some("powerpc-linux-gnu"),
+            "powerpc64le-unknown-linux-gnu" => Some("powerpc64le-linux-gnu"),
+            "riscv32i-unknown-none-elf" => self.find_working_gnu_prefix(&[
+                "riscv32-unknown-elf",
+                "riscv64-unknown-elf",
+                "riscv-none-embed",
+            ]),
+            "riscv32imac-unknown-none-elf" => self.find_working_gnu_prefix(&[
+                "riscv32-unknown-elf",
+                "riscv64-unknown-elf",
+                "riscv-none-embed",
+            ]),
+            "riscv32imc-unknown-none-elf" => self.find_working_gnu_prefix(&[
+                "riscv32-unknown-elf",
+                "riscv64-unknown-elf",
+                "riscv-none-embed",
+            ]),
+            "riscv64gc-unknown-none-elf" => self.find_working_gnu_prefix(&[
+                "riscv64-unknown-elf",
+                "riscv32-unknown-elf",
+                "riscv-none-embed",
+            ]),
+            "riscv64imac-unknown-none-elf" => self.find_working_gnu_prefix(&[
+                "riscv64-unknown-elf",
+                "riscv32-unknown-elf",
+                "riscv-none-embed",
+            ]),
+            "riscv64gc-unknown-linux-gnu" => Some("riscv64-linux-gnu"),
+            "s390x-unknown-linux-gnu" => Some("s390x-linux-gnu"),
+            "sparc-unknown-linux-gnu" => Some("sparc-linux-gnu"),
+            "sparc64-unknown-linux-gnu" => Some("sparc64-linux-gnu"),
+            "sparc64-unknown-netbsd" => Some("sparc64--netbsd"),
+            "sparcv9-sun-solaris" => Some("sparcv9-sun-solaris"),
+            "armv7a-none-eabi" => Some("arm-none-eabi"),
+            "armv7a-none-eabihf" => Some("arm-none-eabi"),
+            "armebv7r-none-eabi" => Some("arm-none-eabi"),
+            "armebv7r-none-eabihf" => Some("arm-none-eabi"),
+            "armv7r-none-eabi" => Some("arm-none-eabi"),
+            "armv7r-none-eabihf" => Some("arm-none-eabi"),
+            "thumbv6m-none-eabi" => Some("arm-none-eabi"),
+            "thumbv7em-none-eabi" => Some("arm-none-eabi"),
+            "thumbv7em-none-eabihf" => Some("arm-none-eabi"),
+            "thumbv7m-none-eabi" => Some("arm-none-eabi"),
+            "thumbv8m.base-none-eabi" => Some("arm-none-eabi"),
+            "thumbv8m.main-none-eabi" => Some("arm-none-eabi"),
+            "thumbv8m.main-none-eabihf" => Some("arm-none-eabi"),
+            "x86_64-pc-windows-gnu" => Some("x86_64-w64-mingw32"),
+            "x86_64-uwp-windows-gnu" => Some("x86_64-w64-mingw32"),
+            "x86_64-rumprun-netbsd" => Some("x86_64-rumprun-netbsd"),
+            "x86_64-unknown-linux-musl" => Some("musl"),
+            "x86_64-unknown-netbsd" => Some("x86_64--netbsd"),
+            _ => None,
+        }
+        .map(|x| x.to_owned()))
+    }
+
+    /// Some platforms have multiple, compatible, canonical prefixes. Look through
+    /// each possible prefix for a compiler that exists and return it. The prefixes
+    /// should be ordered from most-likely to least-likely.
+    fn find_working_gnu_prefix(&self, prefixes: &[&'static str]) -> Option<&'static str> {
+        let suffix = if self.cpp { "-g++" } else { "-gcc" };
+        let extension = std::env::consts::EXE_SUFFIX;
+
+        // Loop through PATH entries searching for each toolchain. This ensures that we
+        // are more likely to discover the toolchain early on, because chances are good
+        // that the desired toolchain is in one of the higher-priority paths.
+        env::var_os("PATH")
+            .as_ref()
+            .and_then(|path_entries| {
+                env::split_paths(path_entries).find_map(|path_entry| {
+                    for prefix in prefixes {
+                        let target_compiler = format!("{}{}{}", prefix, suffix, extension);
+                        if path_entry.join(&target_compiler).exists() {
+                            return Some(prefix);
+                        }
+                    }
+                    None
+                })
+            })
+            .map(|prefix| *prefix)
+            .or_else(||
+            // If no toolchain was found, provide the first toolchain that was passed in.
+            // This toolchain has been shown not to exist, however it will appear in the
+            // error that is shown to the user which should make it easier to search for
+            // where it should be obtained.
+            prefixes.first().map(|prefix| *prefix))
+    }
+
     fn get_target(&self) -> Result<String, Error> {
         match self.target.clone() {
             Some(t) => Ok(t),
@@ -2326,6 +2454,63 @@ impl Build {
             println!("{}", s);
         }
     }
+
+    fn fix_env_for_apple_os(&self, cmd: &mut Command) -> Result<(), Error> {
+        let target = self.get_target()?;
+        let host = self.get_host()?;
+        if host.contains("apple-darwin") && target.contains("apple-darwin") {
+            // If, for example, `cargo` runs during the build of an XCode project, then `SDKROOT` environment variable
+            // would represent the current target, and this is the problem for us, if we want to compile something
+            // for the host, when host != target.
+            // We can not just remove `SDKROOT`, because, again, for example, XCode add to PATH
+            // /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
+            // and `cc` from this path can not find system include files, like `pthread.h`, if `SDKROOT`
+            // is not set
+            if let Ok(sdkroot) = env::var("SDKROOT") {
+                if !sdkroot.contains("MacOSX") {
+                    let macos_sdk = self.apple_sdk_root("macosx")?;
+                    cmd.env("SDKROOT", macos_sdk);
+                }
+            }
+            // Additionally, `IPHONEOS_DEPLOYMENT_TARGET` must not be set when using the Xcode linker at
+            // "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld",
+            // although this is apparently ignored when using the linker at "/usr/bin/ld".
+            cmd.env_remove("IPHONEOS_DEPLOYMENT_TARGET");
+        }
+        Ok(())
+    }
+
+    fn apple_sdk_root(&self, sdk: &str) -> Result<OsString, Error> {
+        let mut cache = self
+            .apple_sdk_root_cache
+            .lock()
+            .expect("apple_sdk_root_cache lock failed");
+        if let Some(ret) = cache.get(sdk) {
+            return Ok(ret.clone());
+        }
+
+        let sdk_path = self
+            .cmd("xcrun")
+            .arg("--show-sdk-path")
+            .arg("--sdk")
+            .arg(sdk)
+            .stderr(Stdio::inherit())
+            .output()?
+            .stdout;
+
+        let sdk_path = match String::from_utf8(sdk_path) {
+            Ok(p) => p,
+            Err(_) => {
+                return Err(Error::new(
+                    ErrorKind::IOError,
+                    "Unable to determine iOS SDK path.",
+                ));
+            }
+        };
+        let ret: OsString = sdk_path.trim().into();
+        cache.insert(sdk.into(), ret.clone());
+        Ok(ret)
+    }
 }
 
 impl Default for Build {
@@ -2343,6 +2528,21 @@ impl Tool {
         Self::with_features(path, clang_driver, false)
     }
 
+    #[cfg(windows)]
+    /// Explictly set the `ToolFamily`, skipping name-based detection.
+    fn with_family(path: PathBuf, family: ToolFamily) -> Self {
+        Self {
+            path: path,
+            cc_wrapper_path: None,
+            cc_wrapper_args: Vec::new(),
+            args: Vec::new(),
+            env: Vec::new(),
+            family: family,
+            cuda: false,
+            removed_args: Vec::new(),
+        }
+    }
+
     fn with_features(path: PathBuf, clang_driver: Option<&str>, cuda: bool) -> Self {
         // Try to detect family of the tool from its name, falling back to Gnu.
         let family = if let Some(fname) = path.file_name().and_then(|p| p.to_str()) {
@@ -2651,10 +2851,11 @@ fn command_add_output_file(
     dst: &Path,
     cuda: bool,
     msvc: bool,
+    clang: bool,
     is_asm: bool,
     is_arm: bool,
 ) {
-    if msvc && !cuda && !(is_asm && is_arm) {
+    if msvc && !clang && !cuda && !(is_asm && is_arm) {
         let mut s = OsString::from("-Fo");
         s.push(&dst);
         cmd.arg(s);
@@ -2662,3 +2863,98 @@ fn command_add_output_file(
         cmd.arg("-o").arg(&dst);
     }
 }
+
+// Use by default minimum available API level
+// See note about naming here
+// https://android.googlesource.com/platform/ndk/+/refs/heads/ndk-release-r21/docs/BuildSystemMaintainers.md#Clang
+static NEW_STANDALONE_ANDROID_COMPILERS: [&str; 4] = [
+    "aarch64-linux-android21-clang",
+    "armv7a-linux-androideabi16-clang",
+    "i686-linux-android16-clang",
+    "x86_64-linux-android21-clang",
+];
+
+// New "standalone" C/C++ cross-compiler executables from recent Android NDK
+// are just shell scripts that call main clang binary (from Android NDK) with
+// proper `--target` argument.
+//
+// For example, armv7a-linux-androideabi16-clang passes
+// `--target=armv7a-linux-androideabi16` to clang.
+// So to construct proper command line check if
+// `--target` argument would be passed or not to clang
+fn android_clang_compiler_uses_target_arg_internally(clang_path: &Path) -> bool {
+    if let Some(filename) = clang_path.file_name() {
+        if let Some(filename_str) = filename.to_str() {
+            filename_str.contains("android")
+        } else {
+            false
+        }
+    } else {
+        false
+    }
+}
+
+#[test]
+fn test_android_clang_compiler_uses_target_arg_internally() {
+    for version in 16..21 {
+        assert!(android_clang_compiler_uses_target_arg_internally(
+            &PathBuf::from(format!("armv7a-linux-androideabi{}-clang", version))
+        ));
+        assert!(android_clang_compiler_uses_target_arg_internally(
+            &PathBuf::from(format!("armv7a-linux-androideabi{}-clang++", version))
+        ));
+    }
+    assert!(!android_clang_compiler_uses_target_arg_internally(
+        &PathBuf::from("clang")
+    ));
+    assert!(!android_clang_compiler_uses_target_arg_internally(
+        &PathBuf::from("clang++")
+    ));
+}
+
+fn autodetect_android_compiler(target: &str, host: &str, gnu: &str, clang: &str) -> String {
+    let new_clang_key = match target {
+        "aarch64-linux-android" => Some("aarch64"),
+        "armv7-linux-androideabi" => Some("armv7a"),
+        "i686-linux-android" => Some("i686"),
+        "x86_64-linux-android" => Some("x86_64"),
+        _ => None,
+    };
+
+    let new_clang = new_clang_key
+        .map(|key| {
+            NEW_STANDALONE_ANDROID_COMPILERS
+                .iter()
+                .find(|x| x.starts_with(key))
+        })
+        .unwrap_or(None);
+
+    if let Some(new_clang) = new_clang {
+        if Command::new(new_clang).output().is_ok() {
+            return (*new_clang).into();
+        }
+    }
+
+    let target = target
+        .replace("armv7neon", "arm")
+        .replace("armv7", "arm")
+        .replace("thumbv7neon", "arm")
+        .replace("thumbv7", "arm");
+    let gnu_compiler = format!("{}-{}", target, gnu);
+    let clang_compiler = format!("{}-{}", target, clang);
+
+    // On Windows, the Android clang compiler is provided as a `.cmd` file instead
+    // of a `.exe` file. `std::process::Command` won't run `.cmd` files unless the
+    // `.cmd` is explicitly appended to the command name, so we do that here.
+    let clang_compiler_cmd = format!("{}-{}.cmd", target, clang);
+
+    // Check if gnu compiler is present
+    // if not, use clang
+    if Command::new(&gnu_compiler).output().is_ok() {
+        gnu_compiler
+    } else if host.contains("windows") && Command::new(&clang_compiler_cmd).output().is_ok() {
+        clang_compiler_cmd
+    } else {
+        clang_compiler
+    }
+}
diff --git a/third_party/rust/cc/src/windows_registry.rs b/third_party/rust/cc/src/windows_registry.rs
index 5af3ff73b3..81725026b3 100644
--- a/third_party/rust/cc/src/windows_registry.rs
+++ b/third_party/rust/cc/src/windows_registry.rs
@@ -14,6 +14,11 @@
 use std::process::Command;
 
 use crate::Tool;
+#[cfg(windows)]
+use crate::ToolFamily;
+
+#[cfg(windows)]
+const MSVC_FAMILY: ToolFamily = ToolFamily::Msvc { clang_cl: false };
 
 /// Attempts to find a tool within an MSVC installation using the Windows
 /// registry as a point to search from.
@@ -70,7 +75,7 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {
                     .map(|p| p.join(tool))
                     .find(|p| p.exists())
             })
-            .map(|path| Tool::new(path.into()));
+            .map(|path| Tool::with_family(path.into(), MSVC_FAMILY));
     }
 
     // Ok, if we're here, now comes the fun part of the probing. Default shells
@@ -80,7 +85,7 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {
     // environment variables like `LIB`, `INCLUDE`, and `PATH` to ensure that
     // the tool is actually usable.
 
-    return impl_::find_msvc_15(tool, target)
+    return impl_::find_msvc_15plus(tool, target)
         .or_else(|| impl_::find_msvc_14(tool, target))
         .or_else(|| impl_::find_msvc_12(tool, target))
         .or_else(|| impl_::find_msvc_11(tool, target));
@@ -173,7 +178,9 @@ mod impl_ {
     use std::iter;
     use std::mem;
     use std::path::{Path, PathBuf};
+    use std::str::FromStr;
 
+    use super::MSVC_FAMILY;
     use crate::Tool;
 
     struct MsvcTool {
@@ -200,7 +207,7 @@ mod impl_ {
                 path,
                 include,
             } = self;
-            let mut tool = Tool::new(tool.into());
+            let mut tool = Tool::with_family(tool.into(), MSVC_FAMILY);
             add_env(&mut tool, "LIB", libs);
             add_env(&mut tool, "PATH", path);
             add_env(&mut tool, "INCLUDE", include);
@@ -210,7 +217,7 @@ mod impl_ {
 
     #[allow(bare_trait_objects)]
     fn vs16_instances() -> Box<Iterator<Item = PathBuf>> {
-        let instances = if let Some(instances) = vs15_instances() {
+        let instances = if let Some(instances) = vs15plus_instances() {
             instances
         } else {
             return Box::new(iter::empty());
@@ -220,6 +227,11 @@ mod impl_ {
             let installation_name = instance.installation_name().ok()?;
             if installation_name.to_str()?.starts_with("VisualStudio/16.") {
                 Some(PathBuf::from(instance.installation_path().ok()?))
+            } else if installation_name
+                .to_str()?
+                .starts_with("VisualStudioPreview/16.")
+            {
+                Some(PathBuf::from(instance.installation_path().ok()?))
             } else {
                 None
             }
@@ -233,7 +245,7 @@ mod impl_ {
                 if !path.is_file() {
                     return None;
                 }
-                let mut tool = Tool::new(path);
+                let mut tool = Tool::with_family(path, MSVC_FAMILY);
                 if target.contains("x86_64") {
                     tool.env.push(("Platform".into(), "X64".into()));
                 }
@@ -253,24 +265,34 @@ mod impl_ {
     // Note that much of this logic can be found [online] wrt paths, COM, etc.
     //
     // [online]: https://blogs.msdn.microsoft.com/vcblog/2017/03/06/finding-the-visual-c-compiler-tools-in-visual-studio-2017/
-    fn vs15_instances() -> Option<EnumSetupInstances> {
+    //
+    // Returns MSVC 15+ instances (15, 16 right now), the order should be consider undefined.
+    fn vs15plus_instances() -> Option<EnumSetupInstances> {
         com::initialize().ok()?;
 
         let config = SetupConfiguration::new().ok()?;
         config.enum_all_instances().ok()
     }
 
-    pub fn find_msvc_15(tool: &str, target: &str) -> Option<Tool> {
-        let iter = vs15_instances()?;
-        for instance in iter {
-            let instance = instance.ok()?;
-            let tool = tool_from_vs15_instance(tool, target, &instance);
-            if tool.is_some() {
-                return tool;
-            }
-        }
+    // Inspired from official microsoft/vswhere ParseVersionString
+    // i.e. at most four u16 numbers separated by '.'
+    fn parse_version(version: &str) -> Option<Vec<u16>> {
+        version
+            .split('.')
+            .map(|chunk| u16::from_str(chunk).ok())
+            .collect()
+    }
 
-        None
+    pub fn find_msvc_15plus(tool: &str, target: &str) -> Option<Tool> {
+        let iter = vs15plus_instances()?;
+        iter.filter_map(|instance| {
+            let instance = instance.ok()?;
+            let version = parse_version(instance.installation_version().ok()?.to_str()?)?;
+            let tool = tool_from_vs15plus_instance(tool, target, &instance)?;
+            Some((version, tool))
+        })
+        .max_by(|(a_version, _), (b_version, _)| a_version.cmp(b_version))
+        .map(|(_version, tool)| tool)
     }
 
     // While the paths to Visual Studio 2017's devenv and MSBuild could
@@ -281,7 +303,7 @@ mod impl_ {
     //
     // [more reliable]: https://github.com/alexcrichton/cc-rs/pull/331
     fn find_tool_in_vs15_path(tool: &str, target: &str) -> Option<Tool> {
-        let mut path = match vs15_instances() {
+        let mut path = match vs15plus_instances() {
             Some(instances) => instances
                 .filter_map(|instance| {
                     instance
@@ -304,7 +326,7 @@ mod impl_ {
         }
 
         path.map(|path| {
-            let mut tool = Tool::new(path);
+            let mut tool = Tool::with_family(path, MSVC_FAMILY);
             if target.contains("x86_64") {
                 tool.env.push(("Platform".into(), "X64".into()));
             }
@@ -312,14 +334,20 @@ mod impl_ {
         })
     }
 
-    fn tool_from_vs15_instance(tool: &str, target: &str, instance: &SetupInstance) -> Option<Tool> {
-        let (bin_path, host_dylib_path, lib_path, include_path) = vs15_vc_paths(target, instance)?;
+    fn tool_from_vs15plus_instance(
+        tool: &str,
+        target: &str,
+        instance: &SetupInstance,
+    ) -> Option<Tool> {
+        let (bin_path, host_dylib_path, lib_path, include_path) =
+            vs15plus_vc_paths(target, instance)?;
         let tool_path = bin_path.join(tool);
         if !tool_path.exists() {
             return None;
         };
 
         let mut tool = MsvcTool::new(tool_path);
+        tool.path.push(bin_path.clone());
         tool.path.push(host_dylib_path);
         tool.libs.push(lib_path);
         tool.include.push(include_path);
@@ -334,7 +362,7 @@ mod impl_ {
         Some(tool.into_tool())
     }
 
-    fn vs15_vc_paths(
+    fn vs15plus_vc_paths(
         target: &str,
         instance: &SetupInstance,
     ) -> Option<(PathBuf, PathBuf, PathBuf, PathBuf)> {
@@ -348,6 +376,9 @@ mod impl_ {
         let host = match host_arch() {
             X86 => "X86",
             X86_64 => "X64",
+            // There is no natively hosted compiler on ARM64.
+            // Instead, use the x86 toolchain under emulation (there is no x64 emulation).
+            AARCH64 => "X86",
             _ => return None,
         };
         let target = lib_subdir(target)?;
@@ -394,8 +425,15 @@ mod impl_ {
         let sub = lib_subdir(target)?;
         let (ucrt, ucrt_version) = get_ucrt_dir()?;
 
+        let host = match host_arch() {
+            X86 => "x86",
+            X86_64 => "x64",
+            AARCH64 => "arm64",
+            _ => return None,
+        };
+
         tool.path
-            .push(ucrt.join("bin").join(&ucrt_version).join(sub));
+            .push(ucrt.join("bin").join(&ucrt_version).join(host));
 
         let ucrt_include = ucrt.join("include").join(&ucrt_version);
         tool.include.push(ucrt_include.join("ucrt"));
@@ -404,7 +442,7 @@ mod impl_ {
         tool.libs.push(ucrt_lib.join("ucrt").join(sub));
 
         if let Some((sdk, version)) = get_sdk10_dir() {
-            tool.path.push(sdk.join("bin").join(sub));
+            tool.path.push(sdk.join("bin").join(host));
             let sdk_lib = sdk.join("lib").join(&version);
             tool.libs.push(sdk_lib.join("um").join(sub));
             let sdk_include = sdk.join("include").join(&version);
@@ -413,7 +451,7 @@ mod impl_ {
             tool.include.push(sdk_include.join("winrt"));
             tool.include.push(sdk_include.join("shared"));
         } else if let Some(sdk) = get_sdk81_dir() {
-            tool.path.push(sdk.join("bin").join(sub));
+            tool.path.push(sdk.join("bin").join(host));
             let sdk_lib = sdk.join("lib").join("winv6.3");
             tool.libs.push(sdk_lib.join("um").join(sub));
             let sdk_include = sdk.join("include");
@@ -580,8 +618,10 @@ mod impl_ {
 
     const PROCESSOR_ARCHITECTURE_INTEL: u16 = 0;
     const PROCESSOR_ARCHITECTURE_AMD64: u16 = 9;
+    const PROCESSOR_ARCHITECTURE_ARM64: u16 = 12;
     const X86: u16 = PROCESSOR_ARCHITECTURE_INTEL;
     const X86_64: u16 = PROCESSOR_ARCHITECTURE_AMD64;
+    const AARCH64: u16 = PROCESSOR_ARCHITECTURE_ARM64;
 
     // When choosing the tool to use, we have to choose the one which matches
     // the target architecture. Otherwise we end up in situations where someone
@@ -744,7 +784,7 @@ mod impl_ {
             .map(|path| {
                 let mut path = PathBuf::from(path);
                 path.push("MSBuild.exe");
-                let mut tool = Tool::new(path);
+                let mut tool = Tool::with_family(path, MSVC_FAMILY);
                 if target.contains("x86_64") {
                     tool.env.push(("Platform".into(), "X64".into()));
                 }
diff --git a/third_party/rust/cc/tests/support/mod.rs b/third_party/rust/cc/tests/support/mod.rs
index 7d74719c9f..cde930e90b 100644
--- a/third_party/rust/cc/tests/support/mod.rs
+++ b/third_party/rust/cc/tests/support/mod.rs
@@ -8,7 +8,7 @@ use std::io::prelude::*;
 use std::path::{Path, PathBuf};
 
 use cc;
-use tempdir::TempDir;
+use tempfile::{Builder, TempDir};
 
 pub struct Test {
     pub td: TempDir,
@@ -22,12 +22,24 @@ pub struct Execution {
 
 impl Test {
     pub fn new() -> Test {
+        // This is ugly: `sccache` needs to introspect the compiler it is
+        // executing, as it adjusts its behavior depending on the
+        // language/compiler. This crate's test driver uses mock compilers that
+        // are obviously not supported by sccache, so the tests fail if
+        // RUSTC_WRAPPER is set. rust doesn't build test dependencies with
+        // the `test` feature enabled, so we can't conditionally disable the
+        // usage of `sccache` if running in a test environment, at least not
+        // without setting an environment variable here and testing for it
+        // there. Explicitly deasserting RUSTC_WRAPPER here seems to be the
+        // lesser of the two evils.
+        env::remove_var("RUSTC_WRAPPER");
+
         let mut gcc = PathBuf::from(env::current_exe().unwrap());
         gcc.pop();
         if gcc.ends_with("deps") {
             gcc.pop();
         }
-        let td = TempDir::new_in(&gcc, "gcc-test").unwrap();
+        let td = Builder::new().prefix("gcc-test").tempdir_in(&gcc).unwrap();
         gcc.push(format!("gcc-shim{}", env::consts::EXE_SUFFIX));
         Test {
             td: td,
diff --git a/third_party/rust/cc/tests/test.rs b/third_party/rust/cc/tests/test.rs
index def11f0259..3c9b4dc498 100644
--- a/third_party/rust/cc/tests/test.rs
+++ b/third_party/rust/cc/tests/test.rs
@@ -2,8 +2,18 @@ use crate::support::Test;
 
 mod support;
 
+// Some tests check that a flag is *not* present.  These tests might fail if the flag is set in the
+// CFLAGS or CXXFLAGS environment variables.  This function clears the CFLAGS and CXXFLAGS
+// variables to make sure that the tests can run correctly.
+fn reset_env() {
+    std::env::set_var("CFLAGS", "");
+    std::env::set_var("CXXFLAGS", "");
+}
+
 #[test]
 fn gnu_smoke() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc().file("foo.c").compile("foo");
 
@@ -19,6 +29,8 @@ fn gnu_smoke() {
 
 #[test]
 fn gnu_opt_level_1() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc().opt_level(1).file("foo.c").compile("foo");
 
@@ -27,6 +39,8 @@ fn gnu_opt_level_1() {
 
 #[test]
 fn gnu_opt_level_s() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc().opt_level_str("s").file("foo.c").compile("foo");
 
@@ -56,6 +70,8 @@ fn gnu_debug_fp() {
 
 #[test]
 fn gnu_debug_nofp() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc()
         .debug(true)
@@ -100,6 +116,8 @@ fn gnu_warnings() {
 
 #[test]
 fn gnu_extra_warnings0() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc()
         .warnings(true)
@@ -113,6 +131,8 @@ fn gnu_extra_warnings0() {
 
 #[test]
 fn gnu_extra_warnings1() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc()
         .warnings(false)
@@ -126,6 +146,8 @@ fn gnu_extra_warnings1() {
 
 #[test]
 fn gnu_warnings_overridable() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc()
         .warnings(true)
@@ -154,6 +176,8 @@ fn gnu_x86_64() {
 
 #[test]
 fn gnu_x86_64_no_pic() {
+    reset_env();
+
     for vendor in &["unknown-linux-gnu", "apple-darwin"] {
         let target = format!("x86_64-{}", vendor);
         let test = Test::gnu();
@@ -215,6 +239,8 @@ fn gnu_x86_64_no_plt() {
 
 #[test]
 fn gnu_set_stdlib() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc()
         .cpp_set_stdlib(Some("foo"))
@@ -253,6 +279,8 @@ fn gnu_compile_assembly() {
 
 #[test]
 fn gnu_shared() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc()
         .file("foo.c")
@@ -265,6 +293,8 @@ fn gnu_shared() {
 
 #[test]
 fn gnu_flag_if_supported() {
+    reset_env();
+
     if cfg!(windows) {
         return;
     }
@@ -301,6 +331,8 @@ fn gnu_flag_if_supported_cpp() {
 
 #[test]
 fn gnu_static() {
+    reset_env();
+
     let test = Test::gnu();
     test.gcc()
         .file("foo.c")
@@ -313,6 +345,8 @@ fn gnu_static() {
 
 #[test]
 fn msvc_smoke() {
+    reset_env();
+
     let test = Test::msvc();
     test.gcc().file("foo.c").compile("foo");
 
@@ -327,6 +361,8 @@ fn msvc_smoke() {
 
 #[test]
 fn msvc_opt_level_0() {
+    reset_env();
+
     let test = Test::msvc();
     test.gcc().opt_level(0).file("foo.c").compile("foo");
 
-- 
2.31.1

